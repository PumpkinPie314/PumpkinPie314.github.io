<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>boid_tutorial</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1-Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="2-ECS.html"><strong aria-hidden="true">2.</strong> What is ECS?</a></li><li class="chapter-item expanded "><a href="3-create-world.html"><strong aria-hidden="true">3.</strong> Creating a world</a></li><li class="chapter-item expanded "><a href="4-creating_a_boid.html"><strong aria-hidden="true">4.</strong> Creating a boid</a></li><li class="chapter-item expanded "><a href="5-creating-movement.html"><strong aria-hidden="true">5.</strong> Creating Movement</a></li><li class="chapter-item expanded "><a href="6-making-our-boid-some-friends.html"><strong aria-hidden="true">6.</strong> Making our boid some friends</a></li><li class="chapter-item expanded "><a href="7-alignment.html"><strong aria-hidden="true">7.</strong> Alignment</a></li><li class="chapter-item expanded "><a href="8-cohesion.html"><strong aria-hidden="true">8.</strong> Cohesion</a></li><li class="chapter-item expanded "><a href="9-seperation.html"><strong aria-hidden="true">9.</strong> Seperation</a></li><li class="chapter-item expanded "><a href="z-bibliography.html"><strong aria-hidden="true">10.</strong> bibliography</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">boid_tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="what-is-this-website"><a class="header" href="#what-is-this-website">What is this website?</a></h1>
<p>this is a tutorial on how to make a boid simulation using the bevy game engine written in the rust programing languge.</p>
<h3 id="installation-and-setup"><a class="header" href="#installation-and-setup">installation and setup</a></h3>
<p>this tutorial does not cover setting up the work environment. Here are some links to get you started:</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Install Rust</a></li>
<li><a href="https://bevyengine.org/learn/book/getting-started/setup/">setup bevy environment</a></li>
<li></li>
</ul>
<h1 id="what-are-boids"><a class="header" href="#what-are-boids">What are boids?</a></h1>
<p>A boid is a &quot;bird like object&quot;. 
below you can see a simulation of them all flying around.</p>
<p><img src="https://thumbs.gfycat.com/NearMarvelousCanadagoose-size_restricted.gif" alt="gif" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-ecs"><a class="header" href="#what-is-ecs">What is ECS?</a></h1>
<p>ECS stands for Entities, Components, and Systems. It is a Architecture used to make game or simulations. </p>
<p>You can think of a <strong>component</strong> as a trait or property. Some examples of components would be: position, velocity, direction, time, height, happiness, number of bones, or love of asparagus. </p>
<p>An <strong>entity</strong> is an object or thing in the world. You can think of them as a container of components. An entity has no traits or information associated with it apart from the components it has.</p>
<p>A <strong>System</strong> defines relationships or ways something changes over time. Examples would be how velocity changes position, how gravity changes velocity, an enemy knowing when to attack the player in a game, or when a ball should bounce off a wall</p>
<p><img src="images/ecs_image.png" alt="ecs_image" /></p>
<h1 id="why-is-ecs-useful"><a class="header" href="#why-is-ecs-useful">why is ECS useful?</a></h1>
<p>In programming today, it is better to have composition over inheritance. Using classes and object oriented programming makes iterating on and expanding on existing code. ECS makes this easy.</p>
<p>This project hardly has many different entity types, so class would have probably been fine. However, they don't exist in the bevy game framework.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-world"><a class="header" href="#creating-a-world">Creating a world</a></h1>
<h2 id="dependencies"><a class="header" href="#dependencies">dependencies</a></h2>
<p>this tells rust what dependencies we will be using for our project. </p>
<p>cargo.toml</p>
<pre><code class="language-toml">[package]
name = &quot;boids&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
bevy = &quot;0.10.1&quot;
rand = &quot;0.8.5&quot;
chrono = &quot;0.4.24&quot;

[profile.dev]
opt-level = 1

[profile.dev.package.&quot;*&quot;]
opt-level = 3
</code></pre>
<p>on the bottom of cargo.toml we have profile.dev and profile.dev.package.&quot;*&quot;. This tells rust how optimized we want our code to be compiled at. For all of our packages we want them to be highly optimized, so its 3. For code we write, we want it to compile fast to speed up iteration. so we set everything that isn't a package to 1.</p>
<p>Here is the boilerplate it starts with.</p>
<p>main.rs</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::new().run();
}</code></pre></pre>
<p>first we'll have a little hello world to make sure everything's working</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::new()
    .add_startup_system(hello_world)
    .run();
}
fn hello_world() {
	println!(&quot;hello world!&quot;)
}</code></pre></pre>
<p>After this run</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>and you should see hello world in the terminal. It will take a long time to compile because we are compiling bevy and all the dependencies. It will only do this once. From now on it will only recompile the files we write.</p>
<h2 id="creating-a-camera"><a class="header" href="#creating-a-camera">Creating a camera</a></h2>
<p>in order to see things we need a camera</p>
<p>rename the &quot;hello_world&quot; function. we don't need it anymore. copy the setup_camera function bellow. Although uninteresting, this is our first entity in our ecs system</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::new()
    .add_plugins(DefaultPlugins)
    .add_startup_system(setup_camera)
    .run();
}
fn setup_camera(
    mut commands: Commands
) {
    commands.spawn(Camera2dBundle::default());
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-boid"><a class="header" href="#creating-a-boid">Creating a boid</a></h1>
<p>our next step is to draw the boid on the screen. </p>
<p>our first step is drawing anything on the screen. our new &quot;spawn_boids_system&quot; with spawn an entity using a &quot;ColorMesh2dBundle&quot;.</p>
<p>A bundle is nothing but a collection of components commonly used together. You can even build you own bundles (we wont be doing that). This bundle has all the components we need to get a shape on the screen. </p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::new()
    .add_plugins(DefaultPlugins)
    .add_startup_system(setup_camera)
    .add_startup_system(spawn_boids_system)
    .run();
}
fn setup_camera(
    mut commands: Commands
) {
    commands.spawn(Camera2dBundle::default());
}

fn spawn_boids_system(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
){
    commands.spawn(
        ColorMesh2dBundle {
            material: materials.add(ColorMaterial::from(Color::PURPLE)), 
            mesh: meshes.add(Mesh::from(shape::Quad::default())).into(),
            transform: Transform {
                scale: Vec3::splat(100.0),
                ..default()
            },
            ..default()
        },
    );
}</code></pre></pre>
<p>for bevy to draw on the screen it needs to know:</p>
<ul>
<li>the <strong>material</strong>: what color to draw</li>
<li>what <strong>mesh</strong> to use: what shape to draw</li>
<li>and the <strong>transform</strong>: where to draw and in what rotation/scale.
&quot;ColorMesh2dBundle&quot; has other properties that we do not care about. we can use <code>..default</code> to fill in the default values for the remaining feilds.</li>
</ul>
<p>after running this with </p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>you should see a purple square show up on screen. </p>
<p>we build the square using <code>Mesh::from(shape::Quad::default())</code>. sadly, there is no shape for isosceles triangle that i am aware of so we will have to build our own. It is a good idea to build out mesh is a separate function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...

fn create_triagle_mesh() -&gt; Mesh {
	//build mesh
}

fn spawn_boids_system(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
){
    commands.spawn(
        ColorMesh2dBundle {
            material: materials.add(ColorMaterial::from(Color::PURPLE)), 
            mesh: meshes.add(create_triagle_mesh()).into(),
            transform: Transform {
                scale: Vec3::splat(100.0),
                ..default()
            },
            ..default()
        },
    );
}
<span class="boring">}</span></code></pre></pre>
<p>^we changed the code inside meshes.add(**)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...

fn create_triagle_mesh() -&gt; Mesh {
    let mut mesh = Mesh::new(PrimitiveTopology::TriangleList);
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, vec![
        [0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0],
    ]);
    mesh.set_indices(Some(Indices::U32(vec![0,1,2])));
    mesh
}

...
<span class="boring">}</span></code></pre></pre>
<p>in order to do this we need to import a few things from bevy at the top of our program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy::render::{render_resource::PrimitiveTopology, mesh::Indices};
...
<span class="boring">}</span></code></pre></pre>
<p>I left the coords for the mesh above as 0's. we will fill them in now
<img src="images/mesh_drawing.png" alt="mesh_drawing" /></p>
<p>as you can see we have vertices at [0,2], [-1, -1], and [1, -1].
although we are working in 2d, all meshes in bevy are 3d. In this case all our z coords(toward and away from camera ) will be left as 0. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, vec![
        [0.0, 2.0, 0.0],
        [-1.0, -1.0, 0.0],
        [1.0, -1.0, 0.0],
    ]);
...
<span class="boring">}</span></code></pre></pre>
<p>the reason that we need to add a decimal of 0 is to tell the compiler that these are floating point numbers and not integers. Bevy always uses f32.</p>
<p>the last component we need to complete our boid is a velocity vector. we will define a new component like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
#[derive(Component)]
struct Velocity(Vec3);
...
<span class="boring">}</span></code></pre></pre>
<p>while we only need a Vec2 for because we are only using 2 dimensions, using a Vec3 will allow us to do easier arithmetic with the translation of boids (which have to use Vec3).</p>
<p>then when we spawn the boid we need to add the velocity component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
#[derive(Component)]
struct Velocity(Vec3);

fn spawn_boids_system(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
){
    commands.spawn((
        ColorMesh2dBundle {
            material: materials.add(ColorMaterial::from(Color::PURPLE)), 
            mesh: meshes.add(create_triagle_mesh()).into(),
            transform: Transform {
                scale: Vec3::splat(100.0),
                ..default()
            },
            ..default()
        },
        Velocity(Vec3{x: 0.0, y: 10.0, z: 0.0})
    ));
}
<span class="boring">}</span></code></pre></pre>
<p>^the &quot;spawn&quot; command only take one argument so we need to wrap our 'ColorMesh2dBundle' and 'Velocity' in a new set of parenthesis: <code>commands.spawn((...))</code></p>
<p>our boids now has no velocity in the x direction, and 10.0 in the y. Once we add movement, it should move up by 10 units per frame.</p>
<hr />
<p>here is our program so far:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use bevy::render::{render_resource::PrimitiveTopology, mesh::Indices};

fn main() {
    App::new()
    .add_plugins(DefaultPlugins)
    .add_startup_system(setup_camera)
    .add_startup_system(spawn_boids_system)
    .run();
}
fn setup_camera(
    mut commands: Commands
) {
    commands.spawn(Camera2dBundle::default());
}

fn create_triagle_mesh() -&gt; Mesh {
    let mut mesh = Mesh::new(PrimitiveTopology::TriangleList);
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, vec![
        [0.0, 2.0, 0.0],
        [-1.0, -1.0, 0.0],
        [1.0, -1.0, 0.0],
    ]);
    mesh.set_indices(Some(Indices::U32(vec![0,1,2])));
    mesh
}

#[derive(Component)]
struct Velocity(Vec3);

fn spawn_boids_system(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
){
    commands.spawn((
        ColorMesh2dBundle {
            material: materials.add(ColorMaterial::from(Color::PURPLE)), 
            mesh: meshes.add(create_triagle_mesh()).into(),
            transform: Transform {
                scale: Vec3::splat(100.0),
                ..default()
            },
            ..default()
        },
        Velocity(Vec3{x: 0.0, y: 10.0, z: 0.0})
    ));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-movement"><a class="header" href="#creating-movement">Creating Movement</a></h1>
<p>first we will add a new system to our app:</p>
<p>main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
    .add_plugins(DefaultPlugins)
    .add_startup_system(setup_camera)
    .add_startup_system(spawn_boids_system)
    .add_system(movement_system)
    .run();
}
...</code></pre></pre>
<p>the difference between &quot;add_system&quot; and &quot;add_startup_system&quot; is that startup systems only run once when the program is launched. A regular system runs on every frame.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
fn movement_system(
    time: Res&lt;Time&gt;,
    mut query: Query&lt;(&amp;mut Transform, &amp;Velocity)&gt;
) {
    for (mut transform, velocity) in query.iter_mut() {
        transform.translation += velocity.0 * time.delta_seconds();
    }
}
...
<span class="boring">}</span></code></pre></pre>
<p>our system needs <strong>access</strong> to the boids transform component (this was part of the &quot;ColorMesh2dBundle&quot; bundle) and our velocity component. we will be changing the transform component to move the boid on the screen. this is why we need it to be <strong>mutable</strong>. that is what the &quot;mut&quot; keyword means.</p>
<p>this system iterates over all boids and adds the velocity vector to the translation of the boid.
here is a diagram:</p>
<p><img src="images/adding_vectors.png" alt="add_vectors" /></p>
<p>the reason we use &quot;velocity.0&quot; instead of &quot;velocity&quot; is because our velocity component looks like this: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Velocity(
	Vec3 {
		x: f32,
		y: f32,
		z: f32,
	}
)
<span class="boring">}</span></code></pre></pre>
<p>we want to add the vector inside of the Velocity struct so we need to take our the zeroth element: the vector</p>
<p>the reason we multiply the velocity vector by delta seconds is so that the speed of boids is not tied to the frame rate of the program. delta seconds is the time sense the last frame finished. </p>
<p>if you run the program now, the triangle will move up the screen!</p>
<p>one problem is if we were to change the initial velocity like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        Velocity(Vec3{x: 10.0, y: 10.0, z: 0.0})
<span class="boring">}</span></code></pre></pre>
<p>and run the code, we will see that the triangle doesn't point to where it is headed. It only points up!</p>
<p>to fix this, we need to find the angle the boid should be based on its velocity. 
<img src="images/trig_angle.png" alt="trig_angle" /></p>
<p>Using trigonometry we know that tan(θ) = opposite / adjacent.
so,solving for θ, our boids rotation angle should be atan(velocity.0.y/velocity.0.x)</p>
<p>however there is a big flaw this this approch:
<img src="images/atan2_explaination.png" alt="atan2_explaination" /></p>
<p>with this example of θ, when we decide velocity.0.y by velocity.0.x we get exactly the same number as our previous example. indeed with this approach out boid would only be pointing up toward the top of the screen even if they were moving downward. </p>
<p>modern programming languages, including rust, have a solution to this. the &quot;atan2()&quot; function. this function will properly find the angle θ, even in the third and fourth quadrants:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(velocity.0.y).atan2(velocity.0.x)
<span class="boring">}</span></code></pre></pre>
<p>if you were to run this the our boid faces 90 degrees to the left of where its headed. </p>
<p>this is because it assumes that the angle zero is facing left. but when we built our mesh we made it facing up. to fix this we can rotate the angle by 90 degrees by swapping x and y (taking the reciprocal) and then making it negative:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(-velocity.0.x).atan2(velocity.0.y)
<span class="boring">}</span></code></pre></pre>
<p>to implement this in out code we will add a line that updates the boids rotation every frame:</p>
<p>main.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn movement_system(
    time: Res&lt;Time&gt;,
    mut query: Query&lt;(&amp;mut Transform, &amp;Velocity)&gt;
) {
    for (mut transform, velocity) in query.iter_mut() {
        transform.translation += velocity.0 * time.delta_seconds();
        transform.rotation = Quat::from_rotation_z((-velocity.0.x).atan2(velocity.0.y));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>the rotation need a quaternion. this is just how computers store rotation its not important. we use from_rotation_z because its rotating around the z axis (toward and away the screen is the z axis). </p>
<hr />
<p>here is our program so far:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use bevy::render::{render_resource::PrimitiveTopology, mesh::Indices};

fn main() {
    App::new()
    .add_plugins(DefaultPlugins)
    .add_startup_system(setup_camera)
    .add_startup_system(spawn_boids_system)
    .add_system(movement_system)
    .run();
}
fn setup_camera(
    mut commands: Commands
) {
    commands.spawn(Camera2dBundle::default());
}

fn create_triagle_mesh() -&gt; Mesh {
    let mut mesh = Mesh::new(PrimitiveTopology::TriangleList);
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, vec![
        [0.0, 2.0, 0.0],
        [-1.0, -1.0, 0.0],
        [1.0, -1.0, 0.0],
    ]);
    mesh.set_indices(Some(Indices::U32(vec![0,1,2])));
    mesh
}

#[derive(Component)]
struct Velocity(Vec3);

fn spawn_boids_system(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
){
    commands.spawn((
        ColorMesh2dBundle {
            material: materials.add(ColorMaterial::from(Color::PURPLE)), 
            mesh: meshes.add(create_triagle_mesh()).into(),
            transform: Transform {
                scale: Vec3::splat(100.0),
                ..default()
            },
            ..default()
        },
        Velocity(Vec3{x: -10.0, y: -10.0, z: 0.0})
    ));
}

fn movement_system(
    time: Res&lt;Time&gt;,
    mut query: Query&lt;(&amp;mut Transform, &amp;Velocity)&gt;
) {
    for (mut transform, velocity) in query.iter_mut() {
        transform.translation += velocity.0 * time.delta_seconds();
        transform.rotation = Quat::from_rotation_z((-velocity.0.x).atan2(velocity.0.y));
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-our-boid-some-friends"><a class="header" href="#making-our-boid-some-friends">Making our boid some friends</a></h1>
<p>a boid isn't a boid if its all by itself! in this part we will spawn many boids around randomly.</p>
<p>first we oughta make the boid smaller:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
fn spawn_boids_system(...
...
        ColorMesh2dBundle {
            material: materials.add(ColorMaterial::from(Color::PURPLE)), 
            mesh: meshes.add(create_triagle_mesh()).into(),
            transform: Transform {
                scale: Vec3::splat(10.0),
                ..default()
            },
            ..default()
        },
...
<span class="boring">}</span></code></pre></pre>
<p>we change the scale from <code>Vec3::splat(100.0)</code> to <code>Vec3::splat(100.0)</code>.
the &quot;splat&quot; constructor creates a Vector with the same length on each side. so <code>Vec3::splat(3.0)</code> returns <code>Vec3 {x: 3.0, y:3.0, z:3.0}</code>.</p>
<p>we are going to need the rand crate so we will use it on the top:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy::render::{render_resource::PrimitiveTopology, mesh::Indices};
use rand::Rng;
...
<span class="boring">}</span></code></pre></pre>
<p>we wrap everything in a for loop to repeat 50 times.
we query the window, and get its dimensions.
we change the transform of every boid to a random spot within the window dimensions:</p>
<pre><pre class="playground"><code class="language-rust #1"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_boids_system(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
    window_query: Query&lt;&amp;Window&gt;,
){
    let mut random_thread = rand::thread_rng();
    let window = window_query.get_single().unwrap();
    for _ in 0..=50 {
        commands.spawn((
            ColorMesh2dBundle {
                material: materials.add(ColorMaterial::from(Color::PURPLE)), 
                mesh: meshes.add(create_triagle_mesh()).into(),
                transform: Transform {
                    scale: Vec3::splat(10.0),
                    translation: Vec3 {
                        x: random_thread.gen_range(-window.width()..window.width()),
                        y: random_thread.gen_range(-window.height()..window.height()),
                        z: 0.0,
                    },
                    ..default()
                },
                ..default()
            },
            Velocity(Vec3{x: -10.0, y: -10.0, z: 0.0})
        ));
    }
}

<span class="boring">}</span></code></pre></pre>
<p>when we call rand::thread_rng() we are creating a new random number generator. for performance reasons we should only make one. every number afterword takes the last output as input.</p>
<p>after we have the generator, we use the .gen_range(a..b) function to pick a random number between a and b.</p>
<p>lets make the Velocity random as well:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
            Velocity(Vec3{
                x: random_thread.gen_range(-1.0..1.0),
                y: random_thread.gen_range(-1.0..1.0),
                z: 0.0,
            }.normalize() * Vec3::splat(10.0))
...
<span class="boring">}</span></code></pre></pre>
<p>this picks a <strong>random</strong> point in a cube, 
<strong>normalizes</strong> it so the boid all move at the same speed,
then we <strong>multiply</strong> our random unit vector by 10 using splat(). 10 is the <strong>speed</strong> for our boids.</p>
<p>Right now all out boids slowly drift off to space and never come back. I want to make a boid that disappears off the left side of the screen reappear on the right. And the same for all sides. </p>
<p>we will start with another system:</p>
<pre><pre class="playground"><code class="language-rust">...
fn main() {
    App::new()
    .add_plugins(DefaultPlugins)
    .add_startup_system(setup_camera)
    .add_startup_system(spawn_boids_system)
    .add_system(movement_system)
    .add_system(wrap_around_system)
    .run();
}
...</code></pre></pre>
<p>every frame we check if the current boid has flew further left then the left side of the screen, then move it to the opposite side:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn wrap_around_system(
    window_query: Query&lt;&amp;Window&gt;,
    mut query: Query&lt;&amp;mut Transform&gt;
) {
    let window_entity = window_query.get_single().unwrap();
    let width = window_entity.width();
    let height = window_entity.height();
    for mut boid in query.iter_mut() {
        if boid.translation.x &lt; -width / 2.0 {
            boid.translation.x = width / 2.0
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<p>and then repeat for other 3 walls:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn wrap_around_system(
    window_query: Query&lt;&amp;Window&gt;,
    mut query: Query&lt;&amp;mut Transform&gt;
) {
    let window_entity = window_query.get_single().unwrap();
    let width = window_entity.width();
    let height = window_entity.height();
    for mut boid in query.iter_mut() {
        if boid.translation.x &lt; -width / 2.0 {
            boid.translation.x = width / 2.0
        };
        if boid.translation.x &gt; width / 2.0 {
            boid.translation.x = -width / 2.0
        };
        if boid.translation.y &lt; -height / 2.0 {
            boid.translation.y = height / 2.0
        };
        if boid.translation.y &gt; height / 2.0 {
            boid.translation.y = -height / 2.0
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>here is our program so far:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use bevy::render::{render_resource::PrimitiveTopology, mesh::Indices};
use rand::Rng;

fn main() {
    App::new()
    .add_plugins(DefaultPlugins)
    .add_startup_system(setup_camera)
    .add_startup_system(spawn_boids_system)
    .add_system(movement_system)
    .add_system(wrap_around_system)
    .run();
}
fn setup_camera(
    mut commands: Commands
) {
    commands.spawn(Camera2dBundle::default());
}

fn create_triagle_mesh() -&gt; Mesh {
    let mut mesh = Mesh::new(PrimitiveTopology::TriangleList);
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, vec![
        [0.0, 2.0, 0.0],
        [-1.0, -1.0, 0.0],
        [1.0, -1.0, 0.0],
    ]);
    mesh.set_indices(Some(Indices::U32(vec![0,1,2])));
    mesh
}

#[derive(Component)]
struct Velocity(Vec3);

fn spawn_boids_system(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
    window_query: Query&lt;&amp;Window&gt;,
){
    let mut random_thread = rand::thread_rng();
    let window = window_query.get_single().unwrap();
    for _ in 0..=50 {
        commands.spawn((
            ColorMesh2dBundle {
                material: materials.add(ColorMaterial::from(Color::PURPLE)), 
                mesh: meshes.add(create_triagle_mesh()).into(),
                transform: Transform {
                    scale: Vec3::splat(10.0),
                    translation: Vec3 {
                        x: random_thread.gen_range(-window.width()..window.width()),
                        y: random_thread.gen_range(-window.height()..window.height()),
                        z: 0.0,
                    },
                    ..default()
                },
                ..default()
            },
            Velocity(Vec3{
                x: random_thread.gen_range(-1.0..1.0),
                y: random_thread.gen_range(-1.0..1.0),
                z: 0.0,
            }.normalize() * Vec3::splat(10.0))
        ));
    }
}

fn movement_system(
    time: Res&lt;Time&gt;,
    mut query: Query&lt;(&amp;mut Transform, &amp;Velocity)&gt;
) {
    for (mut transform, velocity) in query.iter_mut() {
        transform.translation += velocity.0 * time.delta_seconds();
        transform.rotation = Quat::from_rotation_z((-velocity.0.x).atan2(velocity.0.y));
    }
}

fn wrap_around_system(
    window_query: Query&lt;&amp;Window&gt;,
    mut query: Query&lt;&amp;mut Transform&gt;
) {
    let window_entity = window_query.get_single().unwrap();
    let width = window_entity.width();
    let height = window_entity.height();
    for mut boid in query.iter_mut() {
        if boid.translation.x &lt; -width / 2.0 {
            boid.translation.x = width / 2.0
        };
        if boid.translation.x &gt; width / 2.0 {
            boid.translation.x = -width / 2.0
        };
        if boid.translation.y &lt; -height / 2.0 {
            boid.translation.y = height / 2.0
        };
        if boid.translation.y &gt; height / 2.0 {
            boid.translation.y = -height / 2.0
        };
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alignment"><a class="header" href="#alignment">Alignment</a></h1>
<p>the boids need to be able to see the boids around them in order to make decisions on how to fly.</p>
<p>we will start by adding a new system for our app called &quot;flocking_system&quot; and it will be the brains of our boids:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
    .add_plugins(DefaultPlugins)
    .add_startup_system(setup_camera)
    .add_startup_system(spawn_boids_system)
    .add_system(movement_system)
    .add_system(wrap_around_system)
    
    .add_system(flocking_system)
    .run();
}</code></pre></pre>
<p>to start off we will try to implement Alignment. </p>
<p>Alignment takes the average direction of all the boids in its area and turns towards it. </p>
<p>so it will move from this:</p>
<p><img src="images/alignment1.png" alt="alignement" /></p>
<p>to this:</p>
<p><img src="images/alignment2.png" alt="alignement" /></p>
<p>here is an intuitive, yet wrong approach:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn flocking_system(
    mut query: Query&lt;(&amp;Transform, &amp;mut Velocity)&gt;
){
    for boid in query.iter_mut() {
        for boid_neighbour in query.iter_mut() {
            //find neighbours and average their velocity
        }
        //change boids velocity closer to average
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-cannot-borrow-query-as-immutable-because-it-is-also-borrowed-as-mutable"><a class="header" href="#error-cannot-borrow-query-as-immutable-because-it-is-also-borrowed-as-mutable">Error: cannot borrow <code>query</code> as immutable because it is also borrowed as mutable</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0502]: cannot borrow `query` as immutable because it is also borrowed as mutable
   --&gt; src/main.rs:106:27
    |
105 |     for boid in query.iter_mut() {
    |                 ----------------
    |                 |
    |                 mutable borrow occurs here
    |                 mutable borrow later used here
106 |         for boid_neighbour in query.iter() {
    |                           ^^^^^^^^^^^^ immutable borrow occurs here
<span class="boring">}</span></code></pre></pre>
<p>this is because we are attempting to read data that we are also mutating. this is a big no no for the rust barrow checker.</p>
<p>this reason is that the first loop is activity changing boids as it goes. and that is in turn changing what the second loop is reading. This leads to undefined behavior and would not have been caught by languages other then rust.</p>
<p>the way that we will solve this is by only reading immutably and build a queue of changes, then at the end apply them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
fn flocking_system(
    mut query: Query&lt;(Entity, &amp;Transform, &amp;mut Velocity)&gt;
){
    let mut queue: Vec&lt;Intruction&gt; = vec![];
    for (boid_a, transform_a, _velocity_a) in query.iter() {
	    for (boid_b, transform_b, velocity_b) in query.iter() {
		    //add up neighbours velocitys
	    };
		//devide by the number of neighbours
		//create turn instruction
		//add instuction to queue
    };
    for (boid, _transform, mut velocity) in query.iter_mut() {
	    //apply instuctions to boids
    }
}
<span class="boring">}</span></code></pre></pre>
<p>to help with this, we will create a new struct to represent one instruction, or one small push to a boid:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Intruction{
    boid: Entity,
    direction: Vec3,
    factor: f32,
}
<span class="boring">}</span></code></pre></pre>
<p>this instruction contains what boid to push, the direction of the push, and how hard to push</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
fn flocking_system(
    mut query: Query&lt;(Entity, &amp;Transform, &amp;mut Velocity)&gt;
){
    let mut queue: Vec&lt;Intruction&gt; = vec![];
    for (boid_a, transform_a, _velocity_a) in query.iter() {
        let position_a = transform_a.translation;
        let mut neighbour_count: u32 = 0;
        let mut average_velocity = Vec3::ZERO;
	    for (boid_b, transform_b, velocity_b) in query.iter() {
            if boid_a == boid_b {continue}; 
            let position_b = transform_b.translation;
            if position_a.distance(position_b) &lt; VISION {
                neighbour_count += 1;
                average_velocity += velocity_b.0;
            };
	    };
        if neighbour_count == 0 {continue};
        average_velocity /= Vec3::splat(neighbour_count as f32);
        let instruction = Intruction {
            boid: boid_a,
            direction: average_velocity,
            factor: 0.2,
        };
        queue.push(instruction);
    };
    for (boid, _transform, mut velocity) in query.iter_mut() {
        for instruction in queue.iter() {
            if instruction.boid != boid {continue};

            let speed = velocity.0.length();
            velocity.0 += instruction.direction * Vec3::splat(instruction.factor);
            velocity.0 = velocity.0.normalize() * speed;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>lets take out some constants to the top of our page so they are easy to change later:</p>
<pre><code>use bevy::prelude::*;
use bevy::render::{render_resource::PrimitiveTopology, mesh::Indices};
use rand::Rng;

const BOID_SPEED: f32 = 90.0;
const BOID_VISION: f32 = 80.0;
const ALIGNMENT_FORCE: f32 = 0.2;
</code></pre>
<hr />
<p>here is our code whole after the constant are in: </p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use bevy::render::{render_resource::PrimitiveTopology, mesh::Indices};
use rand::Rng;

const BOID_SPEED: f32 = 90.0;
const BOID_VISION: f32 = 80.0;
const ALIGNMENT_FORCE: f32 = 0.2;


fn main() {
    App::new()
    .add_plugins(DefaultPlugins)
    .add_startup_system(setup_camera)
    .add_startup_system(spawn_boids_system)
    .add_system(movement_system)
    .add_system(wrap_around_system)

    .add_system(flocking_system)
    .run();
}
fn setup_camera(
    mut commands: Commands
) {
    commands.spawn(Camera2dBundle::default());
}

fn create_triagle_mesh() -&gt; Mesh {
    let mut mesh = Mesh::new(PrimitiveTopology::TriangleList);
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, vec![
        [0.0, 2.0, 0.0],
        [-1.0, -1.0, 0.0],
        [1.0, -1.0, 0.0],
    ]);
    mesh.set_indices(Some(Indices::U32(vec![0,1,2])));
    mesh
}

#[derive(Component)]
struct Velocity(Vec3);

fn spawn_boids_system(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
    window_query: Query&lt;&amp;Window&gt;,
){
    let mut random_thread = rand::thread_rng();
    let window = window_query.get_single().unwrap();
    for _ in 0..=50 {
        commands.spawn((
            ColorMesh2dBundle {
                material: materials.add(ColorMaterial::from(Color::PURPLE)), 
                mesh: meshes.add(create_triagle_mesh()).into(),
                transform: Transform {
                    scale: Vec3::splat(10.0),
                    translation: Vec3 {
                        x: random_thread.gen_range(-window.width()..window.width()),
                        y: random_thread.gen_range(-window.height()..window.height()),
                        z: 0.0,
                    },
                    ..default()
                },
                ..default()
            },
            Velocity(Vec3{
                x: random_thread.gen_range(-1.0..1.0),
                y: random_thread.gen_range(-1.0..1.0),
                z: 0.0,
            }.normalize() * Vec3::splat(BOID_SPEED))
        ));
    }
}

fn movement_system(
    time: Res&lt;Time&gt;,
    mut query: Query&lt;(&amp;mut Transform, &amp;Velocity)&gt;
) {
    for (mut transform, velocity) in query.iter_mut() {
        transform.translation += velocity.0 * time.delta_seconds();
        transform.rotation = Quat::from_rotation_z((-velocity.0.x).atan2(velocity.0.y));
    }
}

fn wrap_around_system(
    window_query: Query&lt;&amp;Window&gt;,
    mut query: Query&lt;&amp;mut Transform&gt;
) {
    let window_entity = window_query.get_single().unwrap();
    let width = window_entity.width();
    let height = window_entity.height();
    for mut boid in query.iter_mut() {
        if boid.translation.x &lt; -width / 2.0 {
            boid.translation.x = width / 2.0
        };
        if boid.translation.x &gt; width / 2.0 {
            boid.translation.x = -width / 2.0
        };
        if boid.translation.y &lt; -height / 2.0 {
            boid.translation.y = height / 2.0
        };
        if boid.translation.y &gt; height / 2.0 {
            boid.translation.y = -height / 2.0
        };
    }
}

struct Intruction{
    boid: Entity,
    direction: Vec3,
    factor: f32,
}

fn flocking_system(
    mut query: Query&lt;(Entity, &amp;Transform, &amp;mut Velocity)&gt;
){
    let mut queue: Vec&lt;Intruction&gt; = vec![];
    for (boid_a, transform_a, _velocity_a) in query.iter() {
        let position_a = transform_a.translation;
        let mut neighbour_count: u32 = 0;
        let mut average_velocity = Vec3::ZERO;
	    for (boid_b, transform_b, velocity_b) in query.iter() {
            if boid_a == boid_b {continue}; 
            let position_b = transform_b.translation;
            if position_a.distance(position_b) &lt; BOID_VISION {
                neighbour_count += 1;
                average_velocity += velocity_b.0;
            };
	    };
        if neighbour_count == 0 {continue};
        average_velocity /= Vec3::splat(neighbour_count as f32);
        let instruction = Intruction {
            boid: boid_a,
            direction: average_velocity,
            factor: ALIGNMENT_FORCE,
        };
        queue.push(instruction);
    };
    for (boid, _transform, mut velocity) in query.iter_mut() {
        for instruction in queue.iter() {
            if instruction.boid != boid {continue};

            let speed = velocity.0.length();
            velocity.0 += instruction.direction * Vec3::splat(instruction.factor);
            velocity.0 = velocity.0.normalize() * speed;
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cohesion"><a class="header" href="#cohesion">Cohesion</a></h1>
<p>cohesion is the force that pulls the boids together. it takes the average position of all the boids around it and point tward that.</p>
<p><img src="images/cohesion1.png" alt="cohesion" />
<img src="images/cohesion2.png" alt="cohesion" /></p>
<p>Now that we have our system for reading the boid's neighbours and changing it's velocity, it will be quite east to implement the other 2 forces</p>
<p>first lets add a new constant</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
const BOID_SPEED: f32 = 90.0;
const BOID_VISION: f32 = 80.0;
const ALIGNMENT_FORCE: f32 = 0.2;
const COHESION_FORCE: f32 = 0.2;
...
<span class="boring">}</span></code></pre></pre>
<p>then in our flocking system we count up and divide to get the average neighbour position. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
    for (boid_a, transform_a, _velocity_a) in query.iter() {
        let position_a = transform_a.translation;
        let mut neighbour_count: u32 = 0;
        let mut average_velocity = Vec3::ZERO;
        let mut average_neighbour_position = Vec3::ZERO;
	    for (boid_b, transform_b, velocity_b) in query.iter() {
            if boid_a == boid_b {continue}; 
            let position_b = transform_b.translation;
            if position_a.distance(position_b) &lt; BOID_VISION {
                neighbour_count += 1;
                average_velocity += velocity_b.0;
                average_neighbour_position += position_b
            };
	    };
        if neighbour_count == 0 {continue};
        average_velocity /= Vec3::splat(neighbour_count as f32);
        average_neighbour_position /= Vec3::splat(neighbour_count as f32);
        ...
    };
<span class="boring">}</span></code></pre></pre>
<p>to find a vector between two points, all we gotta do is subtract one position from another: 
<img src="images/subtract_vec.png" alt="cohesion" /> </p>
<p><img src="images/subtract_vec2.png" alt="cohesion" /></p>
<p><img src="images/subtract_vec3.png" alt="cohesion" /></p>
<p>as you can see, the vector posb - posa gives us a vector from the point and b.</p>
<p>That is the vector we will put in our instruction.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn flocking_system(
    mut query: Query&lt;(Entity, &amp;Transform, &amp;mut Velocity)&gt;
){
    let mut queue: Vec&lt;Intruction&gt; = vec![];
    for (boid_a, transform_a, _velocity_a) in query.iter() {
        let position_a = transform_a.translation;
        let mut neighbour_count: u32 = 0;
        let mut average_velocity = Vec3::ZERO;
        let mut average_neighbour_position = Vec3::ZERO;
	    for (boid_b, transform_b, velocity_b) in query.iter() {
            if boid_a == boid_b {continue}; 
            let position_b = transform_b.translation;
            if position_a.distance(position_b) &lt; BOID_VISION {
                neighbour_count += 1;
                average_velocity += velocity_b.0;
                average_neighbour_position += position_b
            };
	    };
        if neighbour_count == 0 {continue};
        average_velocity /= Vec3::splat(neighbour_count as f32);
        average_neighbour_position /= Vec3::splat(neighbour_count as f32);
        let towards_neighbours = average_neighbour_position - position_a;
        let alignment = Intruction {
            boid: boid_a,
            direction: average_velocity,
            factor: ALIGNMENT_FORCE,
        };
        queue.push(alignment);
        let cohesion = Intruction {
            boid: boid_a,
            direction: towards_neighbours,
            factor: COHESION_FORCE,
        };
        queue.push(cohesion);
    };
    for (boid, _transform, mut velocity) in query.iter_mut() {
        for instruction in queue.iter() {
            if instruction.boid != boid {continue};

            let speed = velocity.0.length();
            velocity.0 += instruction.direction * Vec3::splat(instruction.factor);
            velocity.0 = velocity.0.normalize() * speed;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>^I also renamed &quot;instruction&quot; to &quot;alignment&quot; to be more readable.</p>
<hr />
<p>here is our program so far:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use bevy::render::{render_resource::PrimitiveTopology, mesh::Indices};
use rand::Rng;

const BOID_SPEED: f32 = 90.0;
const BOID_VISION: f32 = 80.0;
const ALIGNMENT_FORCE: f32 = 0.2;
const COHESION_FORCE: f32 = 0.2;


fn main() {
    App::new()
    .add_plugins(DefaultPlugins)
    .add_startup_system(setup_camera)
    .add_startup_system(spawn_boids_system)
    .add_system(movement_system)
    .add_system(wrap_around_system)

    .add_system(flocking_system)
    .run();
}
fn setup_camera(
    mut commands: Commands
) {
    commands.spawn(Camera2dBundle::default());
}

fn create_triagle_mesh() -&gt; Mesh {
    let mut mesh = Mesh::new(PrimitiveTopology::TriangleList);
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, vec![
        [0.0, 2.0, 0.0],
        [-1.0, -1.0, 0.0],
        [1.0, -1.0, 0.0],
    ]);
    mesh.set_indices(Some(Indices::U32(vec![0,1,2])));
    mesh
}

#[derive(Component)]
struct Velocity(Vec3);

fn spawn_boids_system(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
    window_query: Query&lt;&amp;Window&gt;,
){
    let mut random_thread = rand::thread_rng();
    let window = window_query.get_single().unwrap();
    for _ in 0..=50 {
        commands.spawn((
            ColorMesh2dBundle {
                material: materials.add(ColorMaterial::from(Color::PURPLE)), 
                mesh: meshes.add(create_triagle_mesh()).into(),
                transform: Transform {
                    scale: Vec3::splat(10.0),
                    translation: Vec3 {
                        x: random_thread.gen_range(-window.width()..window.width()),
                        y: random_thread.gen_range(-window.height()..window.height()),
                        z: 0.0,
                    },
                    ..default()
                },
                ..default()
            },
            Velocity(Vec3{
                x: random_thread.gen_range(-1.0..1.0),
                y: random_thread.gen_range(-1.0..1.0),
                z: 0.0,
            }.normalize() * Vec3::splat(BOID_SPEED))
        ));
    }
}

fn movement_system(
    time: Res&lt;Time&gt;,
    mut query: Query&lt;(&amp;mut Transform, &amp;Velocity)&gt;
) {
    for (mut transform, velocity) in query.iter_mut() {
        transform.translation += velocity.0 * time.delta_seconds();
        transform.rotation = Quat::from_rotation_z((-velocity.0.x).atan2(velocity.0.y));
    }
}

fn wrap_around_system(
    window_query: Query&lt;&amp;Window&gt;,
    mut query: Query&lt;&amp;mut Transform&gt;
) {
    let window_entity = window_query.get_single().unwrap();
    let width = window_entity.width();
    let height = window_entity.height();
    for mut boid in query.iter_mut() {
        if boid.translation.x &lt; -width / 2.0 {
            boid.translation.x = width / 2.0
        };
        if boid.translation.x &gt; width / 2.0 {
            boid.translation.x = -width / 2.0
        };
        if boid.translation.y &lt; -height / 2.0 {
            boid.translation.y = height / 2.0
        };
        if boid.translation.y &gt; height / 2.0 {
            boid.translation.y = -height / 2.0
        };
    }
}

struct Intruction{
    boid: Entity,
    direction: Vec3,
    factor: f32,
}

fn flocking_system(
    mut query: Query&lt;(Entity, &amp;Transform, &amp;mut Velocity)&gt;
){
    let mut queue: Vec&lt;Intruction&gt; = vec![];
    for (boid_a, transform_a, _velocity_a) in query.iter() {
        let position_a = transform_a.translation;
        let mut neighbour_count: u32 = 0;
        let mut average_velocity = Vec3::ZERO;
        let mut average_neighbour_position = Vec3::ZERO;
	    for (boid_b, transform_b, velocity_b) in query.iter() {
            if boid_a == boid_b {continue}; 
            let position_b = transform_b.translation;
            if position_a.distance(position_b) &lt; BOID_VISION {
                neighbour_count += 1;
                average_velocity += velocity_b.0;
                average_neighbour_position += position_b
            };
	    };
        if neighbour_count == 0 {continue};
        average_velocity /= Vec3::splat(neighbour_count as f32);
        average_neighbour_position /= Vec3::splat(neighbour_count as f32);
        let towards_neighbours = average_neighbour_position - position_a;
        let alignment = Intruction {
            boid: boid_a,
            direction: average_velocity,
            factor: ALIGNMENT_FORCE,
        };
        queue.push(alignment);
        let cohesion = Intruction {
            boid: boid_a,
            direction: towards_neighbours,
            factor: COHESION_FORCE,
        };
        queue.push(cohesion);
    };
    for (boid, _transform, mut velocity) in query.iter_mut() {
        for instruction in queue.iter() {
            if instruction.boid != boid {continue};

            let speed = velocity.0.length();
            velocity.0 += instruction.direction * Vec3::splat(instruction.factor);
            velocity.0 = velocity.0.normalize() * speed;
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="separation"><a class="header" href="#separation">Separation</a></h1>
<p>after our last section, our boid would all turn towards each other and face the same way, but they all ended up merging into the same space. the separation force pulls the boids apart when they get too close. </p>
<p><img src="images/seperation.png" alt="seperation1" />
<img src="images/seperation2.png" alt="seperation1" /></p>
<p>to start we will add two more constants: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const BOID_SPEED: f32 = 150.0;
const BOID_VISION: f32 = 80.0;
const BOID_COLLISION_RADIUS: f32 = 30.0;
const ALIGNMENT_FORCE: f32 = 0.2;
const COHESION_FORCE: f32 = 0.2;
const SEPERAION_FORCE: f32 = 0.3;
<span class="boring">}</span></code></pre></pre>
<p>this one is the easiest to implement because we don't need to take any averages. </p>
<p>we already know to move boid a towards boid b we would do <code>posb - posa</code>. To move it away we just invert the vector. So <code>-(posb - posa)</code> or <code>posa - posb</code></p>
<p>here is the implementation: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
	    for (boid_b, transform_b, velocity_b) in query.iter() {
            if boid_a == boid_b {continue}; 
            let position_b = transform_b.translation;
            if position_a.distance(position_b) &lt; BOID_VISION {
                neighbour_count += 1;
                average_velocity += velocity_b.0;
                average_neighbour_position += position_b
            };
            if position_a.distance(position_b) &lt; BOID_COLLISION_RADIUS {
                let away_vector = position_a - position_b;
                let seperation = Intruction {
                    boid: boid_a,
                    direction: away_vector,
                    factor: SEPERAION_FORCE,
                };
                queue.push(seperation);
            }
	    };
...
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliography"><a class="header" href="#bibliography">bibliography</a></h1>
<blockquote>
<p>Demšar, &amp; Lebar Bajec, I. (2014). Simulated Predator Attacks on Flocks: A Comparison of Tactics. Artificial Life, 20(3), 343–359. https://doi.org/10.1162/ARTL_a_00135</p>
</blockquote>
<blockquote>
<p>Niizato, Sakamoto, K., Mototake, Y.-I., Murakami, H., Tomaru, T., Hoshika, T., &amp; Fukushima, T. (2020). Finding continuity and discontinuity in fish schools via integrated information theory. PloS One, 15(2), e0229573–e0229573. https://doi.org/10.1371/journal.pone.0229573</p>
</blockquote>
<blockquote>
<p>Joydip Kanjilal. <em>Entity Framework Tutorial - Second Edition</em>. Packt Publishing, 2015. <em>EBSCOhost</em>, search.ebscohost.com/login.aspx?direct=true&amp;AuthType=ip&amp;db=e000xna&amp;AN=1056283&amp;site=ehost-live&amp;scope=site.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
